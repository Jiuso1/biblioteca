/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorBiblioteca.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estructuras de datos para la práctica 1.
TLibro *Biblioteca = NULL; // Vector dinámico de libros
int NumLibros = 0;
// Número de libros almacenados en el vector dinámico.
int Tama = 0;
// Tamaño del vector dinámico. El incremento será por bloques de 4 libros.
int IdAdmin = -1;
// Copia del Identificador de Administración enviado al usuario.
Cadena NomFichero = "";
// Copia del nombre del último fichero binario que se ha cargado en memoria.
int CampoOrdenacion = 0;
// Copia del último campo de ordenación realizado.

// Función que ayudará a qsort a comparar por el campo deseado. Mirar man qsort.
int compararCampo(const void *p1, const void *p2)
{
	// En función del campo de ordenación compararemos una cosa u otra.
	switch (CampoOrdenacion)
	{
	case 0:
	{ // Por ISBN.
		return strcmp(((struct TLibro *)p1)->Isbn, ((struct TLibro *)p2)->Isbn);
		break;
	}
	case 1:
	{ // Por título.
		return strcmp(((struct TLibro *)p1)->Titulo, ((struct TLibro *)p2)->Titulo);
		break;
	}
	case 2:
	{ // Por autor.
		return strcmp(((struct TLibro *)p1)->Autor, ((struct TLibro *)p2)->Autor);
		break;
	}
	case 3:
	{ // Por anho.
		// Como Anio es entero, se compara devolviendo la resta y no con strcmp.
		return ((struct TLibro *)p1)->Anio - ((struct TLibro *)p2)->Anio;
		break;
	}
	case 4:
	{ // Por país.
		return strcmp(((struct TLibro *)p1)->Pais, ((struct TLibro *)p2)->Pais);
		break;
	}
	case 5:
	{ // Por idioma.
		return strcmp(((struct TLibro *)p1)->Idioma, ((struct TLibro *)p2)->Idioma);
		break;
	}
	case 6:
	{ // Por nº de libros Disponibles.
		return ((struct TLibro *)p1)->NoLibros - ((struct TLibro *)p2)->NoLibros;
		break;
	}
	case 7:
	{ // Por nº de libros Prestados.
		return ((struct TLibro *)p1)->NoPrestados - ((struct TLibro *)p2)->NoPrestados;
		break;
	}
	case 8:
	{ // Por nº libros en Espera.
		return ((struct TLibro *)p1)->NoListaEspera - ((struct TLibro *)p2)->NoListaEspera;
		break;
	}
	}
}

int *conexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;
	int contrasenha = *argp;

	if (contrasenha != 1234)
	{
		result = -2;
	}
	else if (IdAdmin != -1)
	{ // Si IdAdmin es igual a -1, no hay ningún administrador conectado entonces.
		result = -1;
	}
	else
	{
		// Como todo está correcto, podemos entrar como administradores:
		IdAdmin = 1 + rand() % RAND_MAX;
		result = IdAdmin;
	}

	return &result;
}

bool_t *
desconexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;
	int idAdminCliente = *argp; // Id pasado por el cliente.

	if (IdAdmin != idAdminCliente)
	{
		result = FALSE;
	}
	else
	{
		IdAdmin = -1; // idAdmin pasa a ser -1 porque ya no hay ningún administrador conectado.
		result = TRUE;
	}

	return &result;
}

int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;
	const int idAdminCliente = argp->Ida; // Id pasado por el cliente.
	FILE *ficheroDatos = NULL;
	TLibro libro = {};

	strcpy(NomFichero, argp->Datos);

	if (IdAdmin != idAdminCliente)
	{
		result = -1;
	}
	else
	{
		ficheroDatos = fopen(NomFichero, "rb"); // Abrimos el fichero en modo lectura y modo binario.
		if (ficheroDatos == NULL)
		{
			result = 0;
		}
		else
		{
			result = 1;
			// El id administrador coincide y además hemos conseguido abrir el fichero.
			fread(&NumLibros, sizeof(NumLibros), 1, ficheroDatos);
			Biblioteca = (TLibro *)malloc(sizeof(TLibro) * NumLibros); // Reservamos memoria a la Biblioteca, justo la necesaria para cargar exactamente el nº de libros del archivo.
			if (Biblioteca == NULL)
			{
				printf("ERROR: no se ha conseguido reservar memoria dinamica para los libros\n");
			}
			else
			{
				fread(Biblioteca, sizeof(libro) * NumLibros, NumLibros, ficheroDatos); // Leemos tantos libros como NumLibros diga. Los guardamos en Biblioteca.
				qsort(Biblioteca, NumLibros, sizeof(struct TLibro), compararCampo);	   // https://www.geeksforgeeks.org/sort-array-of-structs-with-qsort-in-c/
			}
			fclose(ficheroDatos); // Cerramos el fichero.
		}
	}

	return &result;
}

bool_t *
guardardatos_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;
	const int idAdminCliente = *argp; // Id pasado por el cliente.
	FILE *ficheroDatos = NULL;

	if (IdAdmin != idAdminCliente)
	{
		result = FALSE;
	}
	else
	{
		ficheroDatos = fopen(NomFichero, "wb"); // Abrimos el fichero en modo escritura y modo binario.
		if (ficheroDatos == NULL)
		{
			result = FALSE;
		}
		else
		{
			if (Biblioteca == NULL || NumLibros <= 0)
			{
				result = FALSE;
			}
			else
			{
				result = TRUE;															 // Podemos salvar la información.
				fwrite(&NumLibros, sizeof(NumLibros), 1, ficheroDatos);					 // Escribimos el número de libros.
				fwrite(Biblioteca, sizeof(TLibro) * NumLibros, NumLibros, ficheroDatos); // Escribimos tantos libros como NumLibros diga. Los guardamos en Biblioteca.
			}
			fclose(ficheroDatos);
		}
	}

	return &result;
}

int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp)
{ // Pendiente mejorar y revisar.
	static int result;
	if (argp->Ida != IdAdmin)
		result = -1;
	else
	{
		TLibro nuevoLibro = argp->Libro; // Copiamos el nuevo libro pasado por argumento a una variable.
		bool_t encontrado = FALSE;
		int i = 0;
		while (i < NumLibros && encontrado == FALSE) // Buscamos si hay un libro que ya tenga el mismo ISBN
		{
			if (strcmp(Biblioteca[i].Isbn, nuevoLibro.Isbn) == 0)
			{
				encontrado = TRUE;
				result = 0;
			}
			i++;
		}
		if (encontrado == FALSE) // No hay ningun libro con el mismo ISBN, lo metemos en el array
		{
			NumLibros = NumLibros + 1;
			TLibro *nuevoVector = malloc(NumLibros * sizeof(TLibro));
			memcpy(nuevoVector, Biblioteca, (NumLibros - 1) * sizeof(TLibro));
			nuevoVector[NumLibros - 1] = nuevoLibro;
			free(Biblioteca); // Para evitar memory leak
			Biblioteca = nuevoVector;
			result = 1;
		}
	}
	return &result;
}

int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;
	const TComRet consulta = *argp;			 // Copiamos el argumento.
	const int idAdminCliente = consulta.Ida; // Id pasado por el cliente.
	TLibro clave = {};						 // Clave que utilizaremos para buscar el ISBN dado.
	TLibro *resultado = NULL;				 // Puntero al resultado de la búsqueda.
	int i = 0;
	bool_t encontrado = FALSE; // Vale true cuando se ha encontrado el libro con el ISBN dado.

	if (IdAdmin != idAdminCliente)
	{
		result = -1;
	}
	else
	{
		while (i < NumLibros && encontrado == FALSE)
		{
			if (strcmp(Biblioteca[i].Isbn, consulta.Isbn) == 0)
			{
				encontrado = TRUE; // Si coincide el ISBN hemos encontrado el libro.
			}
			else
			{
				i++;
			}
		}
		if (!encontrado)
		{
			result = 0;
		}
		else
		{
			result = 1;
			Biblioteca[i].NoLibros += consulta.NoLibros; // Aumentamos el número de libros disponbles.
			if (Biblioteca[i].NoLibros > Biblioteca[i].NoListaEspera)
			{														   // Si hay más libros disponibles que gente esperando:
				Biblioteca[i].NoLibros -= Biblioteca[i].NoListaEspera; // El sistema les entrega los libros para que dejen de esperar.
				Biblioteca[i].NoListaEspera = 0;					   // Ya no hay nadie esperando.
			}
			else if (Biblioteca[i].NoLibros < Biblioteca[i].NoListaEspera)
			{														   // Si hay menos libros disponibles que gente esperando:
				Biblioteca[i].NoListaEspera -= Biblioteca[i].NoLibros; // Reducimos el número de personas esperando en la misma cantidad que el número de libros disponible.
				Biblioteca[i].NoLibros = 0;							   // Ya hemos dado todos los libros, no nos quedan.
			}
			qsort(Biblioteca, NumLibros, sizeof(struct TLibro), compararCampo); // https://www.geeksforgeeks.org/sort-array-of-structs-with-qsort-in-c/
		}
	}

	return &result;
}

int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;
	TComRet consulta = *argp;				 // Copiamos el argumento.
	const int idAdminCliente = consulta.Ida; // Id pasado por el cliente.
	int i = 0;								 // Iterador para el bucle while.
	bool_t encontrado = FALSE;				 // Vale true cuando se ha encontrado el libro con el ISBN dado.
	TLibro libro = {};						 // Libro buscado.

	if (IdAdmin != idAdminCliente)
	{
		result = -1;
	}
	else
	{
		while (i < NumLibros && encontrado == FALSE)
		{
			if (strcmp(Biblioteca[i].Isbn, consulta.Isbn) == 0)
			{
				encontrado = TRUE; // Si coincide el ISBN hemos encontrado el libro.
			}
			else
			{
				i++;
			}
		}
		if (!encontrado)
		{
			result = 0;
		}
		else
		{
			libro = Biblioteca[i]; // Si lo hemos encontrado guardamos el libro buscado en la variable.
			if (consulta.NoLibros > libro.NoLibros)
			{
				result = 2; // Si la cantidad a retirar es mayor que la que hay, no hay suficientes ejemplares para ser retirados.
			}
			else
			{
				result = 1;
				libro.NoLibros -= consulta.NoLibros;								// Si no, retiramos los libros.
				Biblioteca[i] = libro;												// Actualizamos el libro en la biblioteca.
				qsort(Biblioteca, NumLibros, sizeof(struct TLibro), compararCampo); // https://www.geeksforgeeks.org/sort-array-of-structs-with-qsort-in-c/
			}
		}
	}

	return &result;
}

bool_t *
ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp)
{
	static bool_t result;
	const TOrdenacion ordenar = *argp;		// Copiamos el parámetro a una variable.
	const int idAdminCliente = ordenar.Ida; // Id pasado por el cliente.

	if (IdAdmin != idAdminCliente)
	{
		result = FALSE; // No hemos podido ordenar al tener un id distinto. Tampoco guardaremos el campo de ordenación.
	}
	else
	{
		result = TRUE;					 // Podemos ordenar.
		CampoOrdenacion = ordenar.Campo; // Guardamos el campo de ordenación en el servidor.
		// Procedemos a ordenar el array. Le pasamos el array, el nº de libros, lo que ocupa un libro y cómo compara:
		qsort(Biblioteca, NumLibros, sizeof(struct TLibro), compararCampo); // https://www.geeksforgeeks.org/sort-array-of-structs-with-qsort-in-c/
																			// compararCampo ya tiene en cuenta el campo deseado por el que ordenaremos.
	}

	return &result;
}

int *nlibros_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;

	result = NumLibros; // Solo queremos retornar el número de libros.

	return &result;
}

int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;
	const TConsulta consulta = *argp;		 // Copiamos el argumento.
	const int idAdminCliente = consulta.Ida; // Id pasado por el cliente.
	TLibro clave = {};						 // Clave que utilizaremos para buscar el ISBN dado.
	TLibro *resultado = NULL;				 // Puntero al resultado de la búsqueda.
	int i = 0;
	bool_t encontrado = FALSE; // Vale true cuando se ha encontrado el libro con el ISBN dado.

	if (IdAdmin != idAdminCliente)
	{
		result = -2;
	}
	else
	{
		result = -1; // Inicializamos result a -1. Si no se encuentra ningún libro con el ISBN solicitado, result valdrá -1.
		while (i < NumLibros && encontrado == FALSE)
		{
			if (strcmp(Biblioteca[i].Isbn, consulta.Datos) == 0)
			{
				encontrado = TRUE; // Si coincide el ISBN hemos encontrado el libro.
				result = i;		   // Guardamos la posición del libro.
			}
			else
			{
				i++;
			}
		}
	}

	return &result;
}

TLibro *
descargar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static TLibro result;
	const int i = argp->Pos;			  // Índice del libro pedido.
	Cadena textoError = "????";			  // Texto asignado a los campos de tipo Cadena cuando se ha producido un error.
	const int idAdminCliente = argp->Ida; // Id pasado por el cliente.

	if (i < 0 || i >= NumLibros)
	{ // i no puede ser ni negativo ni igual o mayor que NumLibros.
		result.Anio = 0;
		result.NoLibros = 0;
		result.NoListaEspera = 0;
		result.NoPrestados = 0;
		strcpy(result.Autor, textoError);
		strcpy(result.Idioma, textoError);
		strcpy(result.Isbn, textoError);
		strcpy(result.Pais, textoError);
		strcpy(result.Titulo, textoError);
	}
	else if (IdAdmin != idAdminCliente)
	{
		result = Biblioteca[i];
		result.NoPrestados = 0;
		result.NoListaEspera = 0;
	}
	else
	{
		// Todo correcto:
		result = Biblioteca[i];
	}

	return &result;
}

int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}
